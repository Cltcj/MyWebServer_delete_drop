# ThreadPool

动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户响应。

动态创建的子进程（或子线程）通常只用来为一个客户服务（除非我们做特殊的处理），这将导致系统上产生大量的细微进程（或线程）。进程（或线程）间的切换将消耗大量CPU时间。

## 进程池

&emsp;&emsp;进程池和线程池相似，线程池是由服务器预先创建的一组子进程这些子进程的数目在3-10个之间。进程池中的所有子进程都运行着相同的代码，并具有相同的属性。当有新任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。主进程选择哪个子进程来为新任务服务，则有两种方式：

* 主进程使用某种算法来主动选择子进程。
* 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上，当有新的任务来，主线程将任务添加到工作队列中。

当选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是：在父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的进程间通信。
![image](https://user-images.githubusercontent.com/81791654/169477369-28fc5b71-5fce-4f9a-b4d2-c0674301b276.png)

### 处理多客户

&emsp;&emsp;在使用进程池处理多客户任务时，监听socket和连接sockets是由主进程统一管理这两种socket。
![image](https://user-images.githubusercontent.com/81791654/169478956-06e419a3-3535-41b7-acf3-33aaa5b04e99.png)

### 半同步/半反应堆线程池

&emsp;&emsp;使用一个工作队列完全解除了主线程和工作线程的耦合关系；主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它，如果要将该线程池应用到实际服务器程序中，那么我们必须所有客户请求都是无状态的因为同一个连接上的不同请求可能会由不同的线程处理。

服务器编程基本框架：主要由I/O单元，逻辑单元和网络存储单元组成，其中每个单元之间通过请求队列进行通信，从而协同完成任务。其中I/O单元用于处理客户端连接，读写网络数据；逻辑单元用于处理业务逻辑的线程；网络存储单元指本地数据库和文件等。

## 五种I/O模型

阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。

reactor模式中，主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(逻辑单元 )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由同步I/O实现。

proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由异步I/O实现

同步I/O模型的工作流程如下（epoll_wait为例）：

主线程往epoll内核事件表注册socket上的读就绪事件。

主线程调用epoll_wait等待socket上有数据可读

当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。

睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件

主线程调用epoll_wait等待socket可写。

当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。

## 同步I/O模拟proactor模式

由于异步I/O并不成熟，实际中使用较少，这里将使用同步I/O模拟实现proactor模式。

同步I/O模型的工作流程如下（epoll_wait为例）：

> * 主线程往epoll内核事件表注册socket上的读就绪事件。
* 主线程调用epoll_wait等待socket上有数据可读
* 当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。
* 睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
* 主线程调用epoll_wait等待socket可写。
* 当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。



## 半同步/半反应堆

半同步/半反应堆并发模式是半同步/半异步的变体，将半异步具体化为某种事件处理模式.

**半同步/半异步模式工作流程**

同步线程用于处理客户逻辑

异步线程用于处理I/O事件

异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中

请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象

**半同步/半反应堆工作流程（以Proactor模式为例）**

主线程充当异步线程，负责监听所有socket上的事件

若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件

如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中

所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

## 线程池分析

线程池的设计模式为半同步/半反应堆，其中反应堆具体为Proactor事件处理模式。

具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。

























