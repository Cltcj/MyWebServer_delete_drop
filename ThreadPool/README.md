# ThreadPool

动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户响应。

动态创建的子进程（或子线程）通常只用来为一个客户服务（除非我们做特殊的处理），这将导致系统上产生大量的细微进程（或线程）。进程（或线程）间的切换将消耗大量CPU时间。

## 进程池

&emsp;&emsp;进程池和线程池相似，线程池是由服务器预先创建的一组子进程这些子进程的数目在3-10个之间。进程池中的所有子进程都运行着相同的代码，并具有相同的属性。当有新任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。主进程选择哪个子进程来为新任务服务，则有两种方式：

* 主进程使用某种算法来主动选择子进程。
* 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上，当有新的任务来，主线程将任务添加到工作队列中。

当选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是：在父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的进程间通信。
![image](https://user-images.githubusercontent.com/81791654/169477369-28fc5b71-5fce-4f9a-b4d2-c0674301b276.png)

### 处理多客户

&emsp;&emsp;在使用进程池处理多客户任务时，监听socket和连接sockets是由主进程统一管理这两种socket。
![image](https://user-images.githubusercontent.com/81791654/169478956-06e419a3-3535-41b7-acf3-33aaa5b04e99.png)

### 半同步/半反应堆线程池

&emsp;&emsp;使用一个工作队列完全解除了主线程和工作线程的耦合关系；主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它，如果要将该线程池应用到实际服务器程序中，那么我们必须所有客户请求都是无状态的因为同一个连接上的不同请求可能会由不同的线程处理。
