




析构函数写成虚函数

&emsp;&emsp;由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类
析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。所以将析构函数声明为虚函数是很有必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的情况发生，要将基类的析构函数声明为虚函数。

构造函数和析构函数是否能写成虚函数？

&emsp;&emsp;构造函数不可以声明为虚函数，但在构造函数中可以调用虚函数，且调用的是正在构造的类的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。虚函数对应一个虚函数表，类中存储一个vptr指向这个虚函数表vtable，如果构造函数是虚函数，就需要通过vtable调用，但是对象没有初始化就没有vptr所以构造函数不能是虚函数。

&emsp;&emsp;析构函数可以定义为虚函数，并且一般情况下，基类析构函数需要定义为虚函数。只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象基类的指针时，才能准确的调用派生类的析构函数，才能准确销毁对象。析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化，但派生类可以根据自己的需求重新改写基类中的纯虚函数。

构造函数、析构函数、虚函数是否声明为内联函数？

首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并以一定真正的内联。

>Register关键字：要求编译器尽可能的将变量存到CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。

构造函数和析构函数声明为内联函数是没有意义的：

《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构函数），致使构造函数/析构函数并不像看上去的那么精简。其次class中的函数默认是inline型的，编译器也只是有选择性的内联，将构造函数和析构函数声明为内联函数是没有什么意义的。

将虚函数声明为inline，要分情况讨论

当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身用虚函数时，会内联展开，前提是函数并不复杂的情况下。



